#!/usr/bin/env python3
"""
vocoder - Daemon version of working Option A dictation
Preserves all fixes: ydotool preference, gain boost, text cleanup
"""

import asyncio
import subprocess
import json
import os
import signal
import socket
import logging
import io
import wave
import re
import yaml
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional, Dict, Any
import tempfile

# Try to import required libraries
try:
    import numpy as np
    import sounddevice as sd
    import httpx
except ImportError as e:
    print(f"Missing dependency: {e}")
    print("Install with: pip install numpy sounddevice httpx pyyaml")
    exit(1)

# Optional systemd support
try:
    from systemd import daemon
    HAS_SYSTEMD = True
except ImportError:
    HAS_SYSTEMD = False

@dataclass
class Config:
    """Configuration with correct defaults"""
    whisper_url: str = "http://127.0.0.1:8771/v1/transcribe"
    sample_rate: int = 48000
    channels: int = 1
    audio_gain_db: float = 15.0
    silence_start: float = 0.5
    silence_stop: float = 2.0
    silence_threshold: float = 0.01  # Lowered from 0.02
    max_duration: int = 30  # Max recording time
    typing_tool_preference: tuple = ("ydotool", "wtype")
    socket_path: str = "/run/user/1000/vocoder.sock"
    clipboard_mode: bool = False  # Whether to use clipboard instead of typing
    
    @classmethod
    def from_yaml(cls, config_path: Path) -> "Config":
        """Load configuration from YAML file"""
        config = cls()
        
        if config_path.exists():
            try:
                with open(config_path, 'r') as f:
                    yaml_data = yaml.safe_load(f)
                    
                if yaml_data:
                    # Load whisper URL
                    if 'whisper_url' in yaml_data:
                        config.whisper_url = yaml_data['whisper_url']
                    
                    # Load audio settings
                    if 'audio' in yaml_data:
                        audio = yaml_data['audio']
                        if 'sample_rate' in audio:
                            config.sample_rate = audio['sample_rate']
                        if 'channels' in audio:
                            config.channels = audio['channels']
                        if 'gain_db' in audio:
                            config.audio_gain_db = audio['gain_db']
                    
                    # Load silence settings
                    if 'silence' in yaml_data:
                        silence = yaml_data['silence']
                        if 'start_threshold' in silence:
                            config.silence_start = silence['start_threshold']
                        if 'stop_threshold' in silence:
                            config.silence_stop = silence['stop_threshold']
                        if 'amplitude' in silence:
                            config.silence_threshold = silence['amplitude']
                    
                    # Load other settings
                    if 'max_duration' in yaml_data:
                        config.max_duration = yaml_data['max_duration']
                    if 'typing_tools' in yaml_data:
                        config.typing_tool_preference = tuple(yaml_data['typing_tools'])
                    if 'socket_path' in yaml_data:
                        config.socket_path = yaml_data['socket_path']
                    if 'clipboard_mode' in yaml_data:
                        config.clipboard_mode = yaml_data['clipboard_mode']
                        
                logging.info(f"Loaded config from {config_path}: sample_rate={config.sample_rate}")
            except Exception as e:
                logging.warning(f"Failed to load config from {config_path}: {e}, using defaults")
        else:
            logging.info(f"Config file {config_path} not found, using defaults")
            
        # Override with environment variables if present
        if "WHISPER_URL" in os.environ:
            config.whisper_url = os.environ["WHISPER_URL"]
        if "MAX_DURATION" in os.environ:
            config.max_duration = int(os.environ["MAX_DURATION"])
        if "CLIPBOARD_MODE" in os.environ:
            config.clipboard_mode = os.environ["CLIPBOARD_MODE"].lower() == "true"
            
        return config

class AudioRecorder:
    """Reimplements Option A's recording logic with gain"""
    
    def __init__(self, config: Config):
        self.config = config
        self.recording = False
        self.audio_buffer = []
        self.silence_counter = 0
        self.stream = None
        
    def audio_callback(self, indata, frames, time, status):
        """Process audio with gain matching Option A's rec gain +15"""
        if status:
            logging.warning(f"Audio status: {status}")
            
        if self.recording:
            # Apply gain (matching Option A's gain +15)
            audio_data = indata[:, 0] * self.config.gain_multiplier
            
            # Clip to prevent overflow
            audio_data = np.clip(audio_data, -1.0, 1.0)
            
            # Silence detection with NaN protection
            if len(audio_data) > 0:
                # Calculate RMS with validation
                squared = audio_data ** 2
                mean_squared = np.mean(squared)
                
                # Protect against NaN/inf
                if np.isfinite(mean_squared) and mean_squared >= 0:
                    rms = np.sqrt(mean_squared)
                else:
                    logging.warning(f"Invalid audio data: mean_squared={mean_squared}")
                    rms = 0.0  # Assume silence on error
                
                # Debug logging
                if hasattr(self, '_debug_counter'):
                    self._debug_counter += 1
                else:
                    self._debug_counter = 0
                
                if self._debug_counter % 30 == 0:  # Log every ~0.5s
                    logging.debug(f"Audio RMS: {rms:.4f}, Threshold: {self.config.silence_threshold:.4f}, Silence: {self.silence_counter:.1f}s")
                
                if rms < self.config.silence_threshold:
                    self.silence_counter += frames / self.config.sample_rate
                else:
                    self.silence_counter = 0
            else:
                logging.warning("Empty audio buffer")
                self.silence_counter += frames / self.config.sample_rate
                
            self.audio_buffer.append(audio_data.copy())
            
            # Auto-stop on silence (matching Option A's behavior)
            if self.silence_counter >= self.config.silence_stop:
                logging.info(f"Stopping due to {self.config.silence_stop}s of silence")
                self.stop_recording()
    
    def start_recording(self):
        """Start recording with proper device selection"""
        logging.info("Starting recording")
        self.recording = True
        self.audio_buffer = []
        self.silence_counter = 0
        
        try:
            # Use system default audio device
            self.stream = sd.InputStream(
                callback=self.audio_callback,
                channels=self.config.channels,
                samplerate=self.config.sample_rate,
                blocksize=1024,
                dtype='float32',
                device=None  # Use system default
            )
            self.stream.start()
            
            # Verify stream is actually running
            if not self.stream.active:
                raise Exception("Stream failed to start")
            
            # Play start sound and notify
            self.play_sound("start")
            self.notify("Recording... (speak now)", 2000)
            
        except Exception as e:
            logging.error(f"Failed to start recording: {e}")
            self.recording = False
            self.play_sound("error")
            self.notify(f"Recording failed: {str(e)}", 3000)
            raise  # Re-raise to make error visible
    
    def stop_recording(self):
        """Stop and return audio matching Option A's format"""
        logging.info("Stopping recording")
        self.recording = False
        
        if self.stream:
            self.stream.stop()
            self.stream.close()
            self.stream = None
        
        self.play_sound("stop")
        
        if self.audio_buffer:
            return np.concatenate(self.audio_buffer)
        return None
    
    def get_audio_data(self):
        """Get recorded audio data without changing recording state"""
        if self.audio_buffer:
            return np.concatenate(self.audio_buffer)
        return None
    
    def play_sound(self, sound_type):
        """Play sounds exactly as Option A does"""
        sounds = {
            "start": "/usr/share/sounds/freedesktop/stereo/message.oga",
            "stop": "/usr/share/sounds/freedesktop/stereo/complete.oga",
            "error": "/usr/share/sounds/freedesktop/stereo/dialog-error.oga"
        }
        
        sound_file = sounds.get(sound_type)
        if sound_file and os.path.exists(sound_file):
            try:
                subprocess.Popen(
                    ["paplay", sound_file], 
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                pass  # Don't fail if sound doesn't play
    
    def notify(self, message, timeout=None):
        """Send notifications like Option A"""
        try:
            cmd = ["notify-send", "Vocoder", message]
            if timeout:
                cmd.extend(["-t", str(timeout)])
            subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except:
            pass  # Don't fail if notify-send isn't available

class WhisperClient:
    """Maintains warm connection to Whisper API"""
    
    def __init__(self, config: Config):
        self.config = config
        self.client = httpx.AsyncClient(
            timeout=30.0,
            limits=httpx.Limits(
                max_keepalive_connections=1,
                keepalive_expiry=60
            )
        )
    
    async def transcribe(self, audio_data: np.ndarray) -> Optional[str]:
        """Transcribe using same API as Option A"""
        if audio_data is None or len(audio_data) == 0:
            return None
            
        # Convert to WAV format as Option A does
        wav_buffer = io.BytesIO()
        with wave.open(wav_buffer, 'wb') as wav:
            wav.setnchannels(self.config.channels)
            wav.setsampwidth(2)  # 16-bit
            wav.setframerate(self.config.sample_rate)
            # Convert float to int16 as Option A does
            audio_int16 = (audio_data * 32767).astype(np.int16)
            wav.writeframes(audio_int16.tobytes())
        
        wav_buffer.seek(0)
        
        # Same API call as Option A
        files = {'file': ('audio.wav', wav_buffer, 'audio/wav')}
        data = {
            'format': 'json',
            'language': 'en',
            'diarize': 'false',
            'model': 'small'  # Better accuracy than tiny
        }
        
        try:
            response = await self.client.post(
                self.config.whisper_url,
                files=files,
                data=data
            )
            
            if response.status_code == 200:
                result = response.json()
                text = result.get('text', '').strip()
                
                if text:
                    # CRITICAL: Apply Option A's text cleanup
                    # Remove ALL newlines to prevent Enter key
                    text = text.replace('\n', ' ').replace('\r', '')
                    # Remove leading/trailing whitespace
                    text = re.sub(r'^\s+|\s+$', '', text)
                    logging.info(f"Transcribed: {len(text)} chars")
                
                return text
            else:
                logging.error(f"Whisper API error: {response.status_code}")
                
        except Exception as e:
            logging.error(f"Transcription error: {e}")
            
        return None
    
    async def close(self):
        """Close the HTTP client"""
        await self.client.aclose()

class TypingHandler:
    """Implements Option A's typing logic exactly"""
    
    def __init__(self, config: Config):
        self.config = config
        self.typing_tool = self.detect_typing_tool()
        logging.info(f"Using typing tool: {self.typing_tool}")
    
    def detect_typing_tool(self):
        """Use Option A's preference: ydotool first, then wtype"""
        for tool in self.config.typing_tool_preference:
            try:
                result = subprocess.run(
                    ["which", tool], 
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    return tool
            except:
                continue
        return None
    
    async def type_text(self, text: str) -> bool:
        """Type text using Option A's exact method"""
        if not self.typing_tool or not text:
            return False
        
        try:
            if self.typing_tool == "ydotool":
                # Check if daemon is running (Option A logic)
                check_daemon = subprocess.run(
                    ["pgrep", "-x", "ydotoold"],
                    capture_output=True
                )
                if check_daemon.returncode != 0:
                    # Try to start daemon
                    subprocess.run(
                        ["systemctl", "--user", "start", "ydotoold"],
                        capture_output=True
                    )
                    await asyncio.sleep(0.5)
                
                # CRITICAL: Use --file - flag WITHOUT sudo
                proc = await asyncio.create_subprocess_exec(
                    "ydotool", "type", "--file", "-",  # No sudo!
                    stdin=asyncio.subprocess.PIPE,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                # Send text without newline
                stdout, stderr = await proc.communicate(text.encode())
                success = proc.returncode == 0
                
                if not success:
                    logging.error(f"ydotool failed: {stderr.decode()}")
                    # Try without --file flag as fallback
                    proc2 = await asyncio.create_subprocess_exec(
                        "ydotool", "type", text,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    stdout2, stderr2 = await proc2.communicate()
                    success = proc2.returncode == 0
                    
                    if not success:
                        logging.error(f"ydotool fallback failed: {stderr2.decode()}")
                        
                return success
                
            elif self.typing_tool == "wtype":
                # Use printf to ensure no trailing newline (Option A method)
                proc = await asyncio.create_subprocess_exec(
                    "wtype", "-",
                    stdin=asyncio.subprocess.PIPE,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await proc.communicate(text.encode())
                success = proc.returncode == 0
                
                if not success:
                    logging.error(f"wtype failed: {stderr.decode()}")
                return success
                
        except Exception as e:
            logging.error(f"Typing error: {e}")
            
        return False
    
    async def copy_to_clipboard(self, text: str):
        """Fallback to clipboard exactly as Option A"""
        try:
            proc = await asyncio.create_subprocess_exec(
                "wl-copy",
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            # Add timeout to prevent hanging
            try:
                await asyncio.wait_for(proc.communicate(text.encode()), timeout=2.0)
            except asyncio.TimeoutError:
                logging.error("wl-copy timed out")
                proc.kill()
                return False
            
            # Use Option A's exact notification message
            subprocess.run([
                "notify-send", "Vocoder", 
                "Typing failed - text copied to clipboard! Press Ctrl+V",
                "-t", "3000"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            return True
        except Exception as e:
            logging.error(f"Clipboard fallback failed: {e}")
            return False

class VocoderDaemon:
    """Main daemon preserving Option A's workflow"""
    
    def __init__(self):
        # Load config from YAML file
        config_path = Path(__file__).parent.parent / "config" / "vocoder.yaml"
        self.config = Config.from_yaml(config_path)
        
        # Calculate gain multiplier from dB
        self.config.gain_multiplier = 10 ** (self.config.audio_gain_db / 20)
        
        self.recorder = AudioRecorder(self.config)
        self.whisper = WhisperClient(self.config)
        self.typer = TypingHandler(self.config)
        self.running = True
        self.server = None
        self.processing = False
        
    async def _process_audio_with_cleanup(self, audio_data):
        """Process audio and clean up processing flag"""
        try:
            await self._process_audio(audio_data)
        finally:
            self.processing = False
            
    async def _process_audio(self, audio_data):
        """Process recorded audio data"""
        logging.info("Processing audio data")
        
        if audio_data is None or len(audio_data) == 0:
            subprocess.run([
                "notify-send", "Vocoder", "No speech detected"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return
        
        # Transcribe
        text = await self.whisper.transcribe(audio_data)
        
        if not text:
            subprocess.run([
                "notify-send", "Vocoder Error", "No transcription received"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.recorder.play_sound("error")
            return
        
        # Type or copy based on mode
        if self.config.clipboard_mode:
            # Always copy to clipboard in clipboard mode
            await self.typer.copy_to_clipboard(text)
            subprocess.run([
                "notify-send", "Vocoder", 
                f"Copied to clipboard: {len(text)} chars",
                "-t", "2000"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            # Type text (with Option A's fallback logic)
            if await self.typer.type_text(text):
                # Success notification as Option A
                subprocess.run([
                    "notify-send", "Vocoder", 
                    f"Transcribed: {len(text)} chars",
                    "-t", "1000"
                ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            else:
                # Fallback to clipboard
                await self.typer.copy_to_clipboard(text)
    
    async def process_dictation(self):
        """Execute Option A's workflow with auto-stop"""
        logging.info("Starting dictation process")
        
        # Set processing flag
        self.processing = True
        
        try:
            # Start recording
            self.recorder.start_recording()
            
            # Wait for recording to complete (silence detection or timeout)
            max_wait = self.config.max_duration
            waited = 0
            while self.recorder.recording and waited < max_wait:
                await asyncio.sleep(0.1)
                waited += 0.1
            
            # Force stop if still recording (timeout)
            if self.recorder.recording:
                logging.info("Max duration reached, stopping")
                audio_data = self.recorder.stop_recording()
            else:
                # Already stopped by silence detection
                audio_data = self.recorder.get_audio_data()
            
            # Process the audio
            await self._process_audio(audio_data)
            
        finally:
            self.processing = False
    
    async def handle_command(self, command: str) -> dict:
        """Process commands from vocoderctl"""
        logging.info(f"Received command: {command}")
        
        # Add processing flag to prevent overlaps
        if not hasattr(self, 'processing'):
            self.processing = False
        
        if command == "start":
            if self.processing:
                return {"status": "busy", "error": "Already processing"}
            # Run dictation in background
            asyncio.create_task(self.process_dictation())
            return {"status": "started"}
            
        elif command == "toggle":
            # Toggle recording on/off
            if self.recorder.recording:
                # Stop recording and process
                logging.info("Stopping recording from toggle")
                audio_data = self.recorder.stop_recording()
                
                # Only process if we're not already processing
                if not self.processing and audio_data is not None:
                    self.processing = True
                    asyncio.create_task(self._process_audio_with_cleanup(audio_data))
                return {"status": "stopped", "recording": False}
            else:
                if self.processing:
                    return {"status": "busy", "error": "Still processing previous recording"}
                # Start new recording
                logging.info("Starting recording from toggle")
                self.recorder.start_recording()
                return {"status": "started", "recording": True}
            
        elif command == "status":
            return {
                "status": "running",
                "typing_tool": self.typer.typing_tool,
                "recording": self.recorder.recording,
                "processing": getattr(self, 'processing', False)
            }
            
        elif command == "stop":
            if self.recorder.recording:
                self.recorder.stop_recording()
            return {"status": "stopped"}
            
        elif command == "shutdown":
            self.running = False
            return {"status": "shutting down"}
            
        else:
            return {"error": f"Unknown command: {command}"}
    
    async def handle_client(self, reader, writer):
        """Handle vocoderctl connections"""
        try:
            data = await reader.read(1024)
            command = data.decode().strip()
            
            result = await self.handle_command(command)
            
            response = json.dumps(result).encode()
            writer.write(response)
            await writer.drain()
            
        except Exception as e:
            logging.error(f"Client handler error: {e}")
        finally:
            writer.close()
            await writer.wait_closed()
    
    async def run(self):
        """Main daemon loop"""
        # Set up logging
        logging.basicConfig(
            level=logging.DEBUG if os.environ.get('DEBUG') else logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        
        logging.info("Starting vocoder daemon")
        
        # Notify systemd we're ready (if available)
        if HAS_SYSTEMD:
            daemon.notify("READY=1")
        
        # Set up IPC socket
        socket_path = Path(self.config.socket_path)
        socket_path.unlink(missing_ok=True)
        
        # Ensure socket directory exists
        socket_path.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            self.server = await asyncio.start_unix_server(
                self.handle_client,
                path=str(socket_path)
            )
            
            # Set permissions
            os.chmod(str(socket_path), 0o600)
            
            logging.info(f"Listening on {socket_path}")
            
            async with self.server:
                await self.server.serve_forever()
                
        except KeyboardInterrupt:
            logging.info("Received interrupt, shutting down")
        except Exception as e:
            logging.error(f"Server error: {e}")
        finally:
            await self.cleanup()
    
    async def cleanup(self):
        """Clean up resources"""
        logging.info("Cleaning up")
        
        if self.recorder.recording:
            self.recorder.stop_recording()
        
        await self.whisper.close()
        
        if self.server:
            self.server.close()
            await self.server.wait_closed()
        
        # Remove socket file
        socket_path = Path(self.config.socket_path)
        socket_path.unlink(missing_ok=True)

async def main():
    """Entry point"""
    daemon = VocoderDaemon()
    
    # Handle signals for graceful shutdown
    loop = asyncio.get_event_loop()
    for sig in (signal.SIGTERM, signal.SIGINT):
        loop.add_signal_handler(sig, lambda: asyncio.create_task(daemon.cleanup()))
    
    await daemon.run()

if __name__ == "__main__":
    asyncio.run(main())